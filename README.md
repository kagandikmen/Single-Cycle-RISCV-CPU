# V-CORE

*(The V stands for Verilog, RISC-V, or perhaps my intention to make the CPU 5-stage some day.)*

**V-CORE** is a 32-bit RISC-V processor written in Verilog. It implements RISC-V ISA base module RV32I, version 2.1. 

### Features

- RV32I (v2.1) compliant, with Zicsr and Zifencei extensions
- Single-cycle von Neumann architecture
- 32 KB unified dual-port dual-clock BRAM-based memory (16 KB code, 16 KB data)
- CSR unit with 4096 CSR registers
- Handles misaligned memory accesses via trap vector `mtvec_handler`
- Fully tested with riscv-tests as of 2025-05-29

## Prerequisites

[RISC-V GNU TOOLCHAIN](https://github.com/riscv-collab/riscv-gnu-toolchain) needs to be installed on the host machine to run the unit tests, or just to compile a program for V-CORE. Installation instructions can be found in its own [README.md](https://github.com/riscv-collab/riscv-gnu-toolchain/blob/master/README.md) file. Please use 
```
./configure --prefix=/opt/riscv --with-abi=ilp32 --with-arch=rv32i
```
while installing RISC-V GNU Toolchain, as this is the configuration required by V-CORE. To run the unit tests, Vivado also needs to be installed. For this, please see AMD's [Downloads](https://www.xilinx.com/support/download.html) portal for Vivado Design Suite. For unit tests, also install libraries `libncurses5` and `libtinfo5` through
```
sudo apt install libncurses5 libtinfo5
```

## Getting Started

To start working with V-CORE, run
```
git clone --recursive https://github.com/kagandikmen/V-CORE.git
```
from your working directory. To run the unit tests, which could also be used to check for correct toolchain setup, use
```
make
```
after navigating into the V-CORE directory. In correct setup, the tests should all pass; there is no test failing as of 2025-05-29. To get rid of all files generated by Vivado during the tests, run
```
make clean_all
```
Find an example of how a generic C file can be compiled to run on V-CORE by navigating to [sw/test/](sw/test/). For the automated Vivado setup please refer to [vivado-setup/README.md](vivado-setup/README.md).

## Project Structure

- `lib/` - Verilog libraries for constants and functions commonly used throughout the design
- `rtl/` - Verilog source code
- `sim/` - Verilog testbenches
- `sw/` - Software helpers such as trap vectors and linker scripts; also includes demo software
- `ut/` - Unit tests taken from [riscv-tests](https://github.com/riscv-software-src/riscv-tests)
- `vivado-setup/` - Helpers for easy setup on Vivado

## Architectural Details

V-CORE has been tested for full RV32I compliance using the unit tests in the [ut](ut/) folder, which are sourced from [riscv-tests](https://github.com/riscv-software-src/riscv-tests), the official test suite provided by RISC-V International.

V-CORE implements a single-cycle von Neumann CPU architecture. In its current configuration, it has a 32 KB unified memory to store both program and data, where the first 16 KB is reserved for programs and the second 16 KB for data. Misaligned accesses to this unified BRAM memory are allowed, where the CPU then raises an exception and jumps to a trap vector to handle the misaligned access.

V-CORE implements 4096 CSR registers in its CSR unit. As of 2025-05-29, the only exception the hardware itself can raise is when a misaligned memory access is attempted. But software can raise any exception through `ecall` and `ebreak` instructions, where the program then jumps to the address stored in the CSR register `MTVEC`.

V-CORE implements `fence` and `fence_i` instructions as pure `NOP`s, as these instructions do not serve any meaningful purpose in a single-core setting.

## Status

The unit tests all pass as of 2025-05-29.

## Contributing

Pull requests, suggestions, and bug reports are all welcome.

## License

V-CORE is licensed under MIT License. See [LICENSE](LICENSE) for details.

V-CORE incorporates components and code from external sources. For detailed license and copyright information regarding these components, please refer to [NOTICE.md](NOTICE.md).